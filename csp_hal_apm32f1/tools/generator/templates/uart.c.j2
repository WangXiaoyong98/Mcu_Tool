{#
 # Licensed under the Apache License v. 2 (the "License")
 # You may not use this file except in compliance with the License.
 # You may obtain a copy of the License at
 #
 #     https://www.apache.org/licenses/LICENSE-2.0.html
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 #
 # Copyright (C) 2025-2025 xqyjlj<xqyjlj@126.com>
 #
 # @author      xqyjlj
 # @file        uart.c.j2
 #
 # Change Logs:
 # Date           Author       Notes
 # ------------   ----------   -----------------------------------------------
 # 2025-11-16     xqyjlj       initial version
 #}
{%- extends "csp-file-base.c.j2" %}

{%- set module = CSP.module %}
{%- set mode = CSP.project|uart_ctrl_mode_t(module) %}
{%- set name = CSP.module|lower() %}

{%- block includes %}
#include "csp/{{ name }}.h"
{%- endblock %}

{%- block function_body %}
{#
{%- set tx_io = CSP.project|usart_io(module + ":TX") %}
{%- set rx_io = CSP.project|usart_io(module + ":RX") %}
{%- set ck_io = CSP.project|usart_io(module + ":CK") %}
#}
void csp_{{ module|lower() }}_init(void)
{
    // GPIO_Config_T gpio_config = {0};
    USART_Config_T uart_config = {0};
{#  #}
    /*!< enable the {{ module }} clock. */
    RCM_EnableAPB1PeriphClock(RCM_APB1_PERIPH_{{ module }});
{#
    RCM_EnableAPB2PeriphClock({{ CSP.project|usart_io_clocks(tx_io, rx_io, ck_io)|join(" | ") }});
#}
    // TODO: io
{#  #}
    uart_config.baudRate = {{ CSP.project|uart_baud_rate_t(module, 115200) }}U;
    uart_config.hardwareFlow = USART_HARDWARE_FLOW_NONE;
    uart_config.mode = {{ CSP.project|uart_mode(module) }};
    uart_config.parity = {{ CSP.project|uart_parity(module) }};
    uart_config.stopBits = {{ CSP.project|uart_stop_bits(module) }};
    uart_config.wordLength = {{ CSP.project|uart_word_length(module) }};
    USART_Config({{ module }}, &uart_config);

{%- if mode == "half_duplex_single_wire_mode" %}
{#  #}
    USART_EnableHalfDuplex({{ module }});
{%- elif mode == "ir_da" %}
{#  #}
    USART_ConfigIrDA({{ module }}, {{ CSP.project|uart_ir_da_mode(module) }});
    USART_ConfigPrescaler({{ module }}, {{ CSP.project|uart_prescaler_t(module) }}U);
    USART_EnableIrDA({{ module }});
{%- elif mode == "multiprocessor_communication" %}
{#  #}
    USART_ConfigWakeUp({{ module }}, {{ CSP.project|uart_wake_up_methode(module) }});

    {%- if CSP.project|uart_wake_up_methode_t(instance) == "addressmark" %}
    USART_Address({{ module }}, {{ CSP.project|uart_address_t(module) }}U);
    {%- endif %}

{%- endif %}
{#  #}
    USART_Enable({{ module }});

{%- if mode == "lin" %}
{#  #}
    USART_ConfigLINBreakDetectLength({{ module }}, {{ CSP.project|uart_break_detect_length(module) }});
    USART_EnableLIN({{ module }});
{%- endif %}
}

int32_t csp_{{ name }}_write(const void *buffer, uint32_t length)
{
    uint32_t i = 0;
    const uint8_t *buf = (const uint8_t *)buffer;

    for (i = 0; i < length; i++)
    {
        while (({{ module }}->STS & USART_FLAG_TXBE) == 0U)
        {
        }
        {{ module }}->DATA_B.DATA = buf[i];
    }

    return 0;
}

int32_t csp_{{ name }}_read(void *buffer, uint32_t length)
{
    uint32_t i = 0;
    uint8_t *buf = (uint8_t *)buffer;

    for (i = 0; i < length; i++)
    {
        while (({{ module }}->STS & USART_FLAG_RXBNE) == 0U)
        {
        }
        buf[i] = {{ module }}->DATA_B.DATA;
    }

    return 0;
}
{%- endblock %}
